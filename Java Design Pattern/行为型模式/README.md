# 行为型模式
在软件系统运行时对象并不是孤立存在的，它们可以通过相互通信协作完成某些功能，一个对象在运行时也将影响到其他对象的运行。行为型模式关注系统中对象之间的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。行为型模式不仅仅关注类和对象本身，还重点关注它们之间的相互作用和职责划分。

行为型模式分为**类行为型模式**和**对象行为型模式**两种，其中类行为型模式适用继承关系在几个类之间分配行为，主要通过多态等方式来分配父类与子类的职责；而对象行为型模式则使用对象的关联关系来分配行为，主要通过对象关联等方式来分配两个或多个类的职责。根据合成复用原则，在系统中复用功能时要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。

| 模式名称 | 定义 | 学习难度 | 使用频率 |
|  ----  | ----  | ----| ----|
| 职责链模式<br>(Chain of Responsibility Pattern) | 避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。 | ★★☆☆☆ | ★★★★☆ |
| 命令模式<br>(Command Pattern) | 将一个请求封装为一个对象，从而可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。 | ★★★☆☆ | ★★★★☆ |
| 解释器模式<br>(Interpreter Pattern) | 定义一个语言的文法，并且建立一个解释器来解释该语言中的句子 | ★★★★★ | ★☆☆☆☆ |
| 迭代器模式<br>(Iterator Pattern) | 提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示。 | ★★★☆☆ | ★★★★★ |
| 中介者模式<br>(Mediator Pattern) | 定义一个对象来封装一系列对象的交互，中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且用户可以独立地改变它们之间的交互。 | ★★★☆☆ | ★★☆☆☆ |
| 备忘录模式<br>(Memento Pattern) | 在不破坏封装的前提下捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 | ★★☆☆☆ | ★★☆☆☆ |
| 状态模式<br>(State Pattern) | 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 | ★★★☆☆ | ★★★☆☆ |
| 观察者模式<br>(Observer Pattern) | 定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。 | ★★★☆☆ | ★★★★★ |
| 策略模式<br>(Strategy Pattern) | 定义一系列算法类，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法独立于使用它的客户而变化。 | ★☆☆☆☆ | ★★★★☆ |
| 模板方法模式<br>(Template Method Pattern) | 定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。 | ★★★★☆ | ★☆☆☆☆ |
| 访问者模式<br>(Visitor Pattern) | 表示一个作用于某对象结构中的各个元素的操作。访问者模式让用户可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 | ★★☆☆☆ | ★★★☆☆ |