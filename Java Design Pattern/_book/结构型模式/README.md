# 结构型模式

结构型模式可以描述两种不同的东西——类与类的实例（对象）。根据这一点，结构型模式可以分为**类型构型模式**和**对象结构型模式**。类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，一般只存在**继承关系**和**实现关系**；而对象结构型模式关心类与对象的组合，通过**关联关系**在一个类中定义另一个类的实例对象，然后通过该对象调用相应的方法。根据合成复用原则，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是对象结构型模式。

| 模式名称 | 定义 | 学习难度 | 使用频率 |
|  ----  | ----  | ----| ----|
| 适配器模式<br>(Adapter Pattern) | 将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作。 | ★★☆☆☆ | ★★★★☆ |
| 桥接模式<br>(Bridge Pattern) | 将抽象部分与它的实现部分分离，使得两者都可以独立地变化。 | ★★★☆☆ | ★★★☆☆ |
| 装饰模式<br>(Decorator Pattern) | 将抽象部分与它的实现部分分离，使得两者都可以独立地变化。 | ★★★☆☆ | ★★★☆☆ |
| 组合模式<br>(Composite Pattern) | 将抽象部分与它的实现部分分离，使得两者都可以独立地变化。 | ★★★☆☆ | ★★★★☆ |
| 外观模式<br>(Facade Pattern) | 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 | ★☆☆☆☆ | ★★★★★ |
|享元模式<br>(Flyweight Pattern) | 运用共享技术有效地支持大量细粒度对象的复用。 | ★★★★☆ | ★☆☆☆☆ |
|代理模式<br>(Proxy Pattern) | 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 | ★★★☆☆ | ★★★★☆ |